## –≠—Ç–∞–ø 1. –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ç–æ—Ç–∏–ø —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
### –¶–µ–ª—å
–°–æ–∑–¥–∞—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ CLI-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ —Å–¥–µ–ª–∞—Ç—å –µ–≥–æ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–º.
### –¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ
1. –ò—Å—Ç–æ—á–Ω–∏–∫–æ–º –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —è–≤–ª—è—é—Ç—Å—è –æ–ø—Ü–∏–∏
–∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.
2. –ö –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º –æ—Ç–Ω–æ—Å—è—Ç—Å—è:
‚Äì –ò–º—è –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º–æ–≥–æ –ø–∞–∫–µ—Ç–∞.
‚Äì URL-–∞–¥—Ä–µ—Å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è –∏–ª–∏ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è.
‚Äì –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã —Å —Ç–µ—Å—Ç–æ–≤—ã–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–º.
‚Äì –í–µ—Ä—Å–∏—è –ø–∞–∫–µ—Ç–∞.
‚Äì –†–µ–∂–∏–º –≤—ã–≤–æ–¥–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ ASCII-–¥–µ—Ä–µ–≤–∞.
‚Äì –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –∞–Ω–∞–ª–∏–∑–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π.
3. (—Ç–æ–ª—å–∫–æ –¥–ª—è —ç—Ç–æ–≥–æ —ç—Ç–∞–ø–∞) –ü—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –≤—ã–≤–µ—Å—Ç–∏ –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã,
–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –≤ —Ñ–æ—Ä–º–∞—Ç–µ –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ.
4. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –¥–ª—è –≤—Å–µ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
5. –†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–∞–ø–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ
–æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ã–º –∫–æ–º–º–∏—Ç–æ–º.
### –†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø—É—Å–∫–∞
<img width="1793" height="242" alt="image" src="https://github.com/user-attachments/assets/1b4d929a-3c03-45ce-8aac-d971cad0a24a" />

### –ö–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã

```java
package src;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class SecondStage {

    private static final Set<String> VALID_KEYS = Set.of(
            "--package-name", "--repo-url", "--repo-path",
            "--mode", "--version", "--ascii", "--max-depth"
    );
    private static final Map<String, String> params = new HashMap<>();


    public static void main(String[] args) {
        try {
            if(args.length == 0) {
                throw new IllegalArgumentException("–û—Ç—Å—É—Ç—Å–≤—É—é—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã");
            }

            for(String argument: args) {
                String[] parameters = argument.split("=");

                if(parameters.length != 2) {
                    throw new IllegalArgumentException("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞");
                }

                String key = parameters[0];
                String value = parameters[1];

                if (!VALID_KEYS.contains(key)){
                    throw new IllegalArgumentException("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä: " + key);
                }

                params.put(key, value);
            }

            validateParameters();
            String packageName = params.get("--package-name");
            String version = params.get("--version");

            if (packageName == null || version == null) {
                throw new IllegalArgumentException("–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --package-name –∏ --version");
            }

            String baseUrl = params.getOrDefault("--repo-url", "https://registry.npmjs.org/");
            if (!baseUrl.endsWith("/")) baseUrl += "/";

            String packageUrl = baseUrl + packageName;
            System.out.println("\n–ü–æ–ª—É—á–∞—é –¥–∞–Ω–Ω—ã–µ –æ –ø–∞–∫–µ—Ç–µ: " + packageUrl);

            String json = fetchJson(packageUrl);

            System.out.println("\n–ü—Ä—è–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è " + packageName + "@" + version + ":");

            printDependencies(json, version);


        } catch (IllegalArgumentException e) {
            System.err.println("[–û—à–∏–±–∫–∞] " + e.getMessage());
            printUsage();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void printDependencies(String json, String version) {
        String versionKey = "\"" + version + "\":{";
        int startVersion = json.indexOf(versionKey);
        if (startVersion == -1) {
            System.out.println("–í–µ—Ä—Å–∏—è " + version + " –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.");
            return;
        }

        int depsIndex = json.indexOf("\"devDependencies\"", startVersion);

        if (depsIndex == -1) {
            System.out.println("–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.");
            return;
        }

        int startBrace = json.indexOf("{", depsIndex);
        int endBrace = findMatchingBrace(json, startBrace);
        if (startBrace == -1 || endBrace == -1) {
            System.out.println("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π.");
            return;
        }

        String depsJson = json.substring(startBrace + 1, endBrace);
        String[] deps = depsJson.split(",");

        for (String dep : deps) {
            String[] pair = dep.split(":");
            if (pair.length == 2) {
//                String name = pair[0].replace("\"", "").trim();
//                String ver = pair[1].replace("\"", "").trim();
                System.out.println(pair[0] + " = " + pair[1]);
            }
        }
    }

    private static int findMatchingBrace(String s, int start) {
        int level = 0;
        for (int i = start; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '{') level++;
            else if (c == '}') {
                level--;
                if (level == 0) return i;
            }
        }
        return -1;
    }


    private static String fetchJson(String urlStr) throws Exception {
        HttpURLConnection conn = (HttpURLConnection) new URL(urlStr).openConnection();
        conn.setRequestMethod("GET");
        conn.setConnectTimeout(5000);
        conn.setReadTimeout(5000);

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {

            StringBuilder response = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }
            return response.toString();
        }
    }

    private static void validateParameters() {
        if(params.containsKey("--max-depth")) {
            try {
                int num = Integer.valueOf(params.get("--max-Depth"));
                if(num <= 0) {
                    throw new NumberFormatException();
                }
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException("–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞: --max-depth");
            }
        }
    }

    private static void printUsage() {
        System.out.println("""
                –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
                java -jar DependencyVisualizer.jar --{parameter}={value} {parameter}={value}
                """);
    }
}
```
## –≠—Ç–∞–ø 2. –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
### –¶–µ–ª—å
–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –ª–æ–≥–∏–∫—É –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö –¥–ª—è –∏—Ö
–¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º–∏
–ø–∞–∫–µ—Ç–æ–≤ –∏ —Å—Ç–æ—Ä–æ–Ω–Ω–∏–º–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞–º–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö
–ø–∞–∫–µ—Ç–æ–≤.
### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è
1. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç –ø–∞–∫–µ—Ç–æ–≤ JavaScript (npm).
2. –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–ª—É—á–∏—Ç—å –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –≤–µ—Ä—Å–∏–∏
–ø–∞–∫–µ—Ç–∞.
3. –ò–∑–≤–ª–µ—á—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä—è–º—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
–ø–∞–∫–µ—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É—è URL-–∞–¥—Ä–µ—Å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è.
4. (—Ç–æ–ª—å–∫–æ –¥–ª—è —ç—Ç–æ–≥–æ —ç—Ç–∞–ø–∞) –í—ã–≤–µ—Å—Ç–∏ –Ω–∞ —ç–∫—Ä–∞–Ω –≤—Å–µ –ø—Ä—è–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
–∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –ø–∞–∫–µ—Ç–∞.
5. –†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–∞–ø–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ
–æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ã–º –∫–æ–º–º–∏—Ç–æ–º.
### –†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø—É—Å–∫–∞
<img width="946" height="206" alt="image" src="https://github.com/user-attachments/assets/a8213e8a-0ff7-4231-8b30-70742fb08205" />

### –ö–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã
```js
const https = require('https');
const http = require('http');

const VALID_KEYS = new Set([
    '--package-name', '--repo-url', '--repo-path',
    '--mode', '--version', '--ascii', '--max-depth'
]);

function main() {
    const args = process.argv.slice(2);
    const params = {};

    try {
        if (args.length === 0) {
            throw new Error('–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã');
        }

        for (const argument of args) {
            const parameters = argument.split('=');

            if (parameters.length !== 2) {
                throw new Error('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞');
            }

            const key = parameters[0];
            const value = parameters[1];

            if (!VALID_KEYS.has(key)) {
                throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä: ${key}`);
            }

            params[key] = value;
        }

        validateParameters(params);
        const packageName = params['--package-name'];
        const version = params['--version'];

        if (!packageName || !version) {
            throw new Error('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --package-name –∏ --version');
        }

        let baseUrl = params['--repo-url'] || 'https://registry.npmjs.org/';
        if (!baseUrl.endsWith('/')) baseUrl += '/';

        const packageUrl = baseUrl + packageName;
        console.log(`\n–ü–æ–ª—É—á–∞—é –¥–∞–Ω–Ω—ã–µ –æ –ø–∞–∫–µ—Ç–µ: ${packageUrl}`);

        fetchJson(packageUrl)
            .then(json => {
                console.log(`\n–ü—Ä—è–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è ${packageName}@${version}:`);
                printDependencies(json, version);
            })
            .catch(error => {
                console.error('[–û—à–∏–±–∫–∞]', error.message);
            });

    } catch (error) {
        console.error('[–û—à–∏–±–∫–∞]', error.message);
        printUsage();
    }
}

function printDependencies(json, version) {
    const versionKey = `"${version}":{`;
    const startVersion = json.indexOf(versionKey);
    
    if (startVersion === -1) {
        console.log(`–í–µ—Ä—Å–∏—è ${version} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.`);
        return;
    }

    const depsIndex = json.indexOf('"devDependencies"', startVersion);

    if (depsIndex === -1) {
        console.log('–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.');
        return;
    }

    const startBrace = json.indexOf('{', depsIndex);
    const endBrace = findMatchingBrace(json, startBrace);
    
    if (startBrace === -1 || endBrace === -1) {
        console.log('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π.');
        return;
    }

    const depsJson = json.substring(startBrace + 1, endBrace);
    const deps = depsJson.split(',');

    for (const dep of deps) {
        if (dep.trim()) {
            const pair = dep.split(':');
            if (pair.length === 2) {
                console.log(`${pair[0]} = ${pair[1]}`);
            }
        }
    }
}

function findMatchingBrace(s, start) {
    let level = 0;
    for (let i = start; i < s.length; i++) {
        const c = s.charAt(i);
        if (c === '{') level++;
        else if (c === '}') {
            level--;
            if (level === 0) return i;
        }
    }
    return -1;
}

function fetchJson(urlStr) {
    return new Promise((resolve, reject) => {
        const protocol = urlStr.startsWith('https:') ? https : http;
        
        const req = protocol.get(urlStr, (res) => {
            if (res.statusCode !== 200) {
                reject(new Error(`HTTP –æ—à–∏–±–∫–∞: ${res.statusCode}`));
                return;
            }

            let data = '';
            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                resolve(data);
            });
        });

        req.on('error', (error) => {
            reject(error);
        });

        req.setTimeout(5000, () => {
            req.destroy();
            reject(new Error('–¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è'));
        });
    });
}

function validateParameters(params) {
    if (params['--max-depth']) {
        const num = parseInt(params['--max-depth']);
        if (isNaN(num) || num <= 0) {
            throw new Error('–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞: --max-depth');
        }
    }
}

function printUsage() {
    console.log(`
–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
node script.js --{parameter}={value} {parameter}={value}
    `);
}


if (require.main === module) {
    main();
}

module.exports = {
    main,
    printDependencies,
    findMatchingBrace,
    fetchJson,
    validateParameters
};
```
## –≠—Ç–∞–ø 3. –û—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
### –¶–µ–ª—å
–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (—Å —É—á–µ—Ç–æ–º —Ç—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–æ—Å—Ç–∏) –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å
–æ—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ –Ω–∏–º.
### –¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ
1. –ü–æ–ª—É—á–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º DFS –±–µ–∑ —Ä–µ–∫—É—Ä—Å–∏–∏.
2. –ü—Ä–æ–≤–æ–¥–∏—Ç—å –∞–Ω–∞–ª–∏–∑ —Å —É—á–µ—Ç–æ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≥–ª—É–±–∏–Ω—ã, –∑–∞–¥–∞–Ω–Ω–æ–π
–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.
3. –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–ª—É—á–∞–∏ –Ω–∞–ª–∏—á–∏—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π.
4. –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–µ–∂–∏–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. –í–º–µ—Å—Ç–æ URL —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è, –¥–∞—Ç—å
–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —É–∫–∞–∑–∞—Ç—å –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –æ–ø–∏—Å–∞–Ω–∏—è –≥—Ä–∞—Ñ–∞
—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è, –≥–¥–µ –ø–∞–∫–µ—Ç—ã –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è –±–æ–ª—å—à–∏–º–∏ –ª–∞—Ç–∏–Ω—Å–∫–∏–º–∏ –±—É–∫–≤–∞–º–∏.
–ü—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å —ç—Ç–æ–≥–æ —ç—Ç–∞–ø–∞ –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö
—Ä–∞–±–æ—Ç—ã —Å —Ç–µ—Å—Ç–æ–≤—ã–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–º.
5. –†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–∞–ø–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ
–æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ã–º –∫–æ–º–º–∏—Ç–æ–º
### –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞–ø—É—Å–∫–∞
<img width="1142" height="580" alt="image" src="https://github.com/user-attachments/assets/f2fc9e80-70f1-4308-a77b-e1a57de38b6b" />
<img width="1369" height="1079" alt="image" src="https://github.com/user-attachments/assets/110e18e0-1b5a-4410-99e9-c1afb39e2f8f" />
<img width="1343" height="1078" alt="image" src="https://github.com/user-attachments/assets/e0d18eca-79c5-4e9a-8f2d-5ea254f3f1b3" />
<img width="912" height="1094" alt="image" src="https://github.com/user-attachments/assets/43ee7637-91e1-49b6-87cb-ffae5e5a9e3c" />

### –ö–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã

```js
const https = require('https');
const http = require('http');
const fs = require('fs').promises;
const path = require('path');

const VALID_KEYS = new Set([
  '--package-name', '--repo-url', '--repo-path',
  '--mode', '--version', '--ascii', '--max-depth', '--ignore-substring'
]);

class IllegalArgumentException extends Error {
  constructor(msg) {
    super(msg);
    this.name = 'IllegalArgumentException';
  }
}

async function main(argv = process.argv.slice(2)) {
  try {
    const params = parseArgs(argv);
    printParams(params);

    validateParameters(params);

    const mode = (params['--mode'] || 'real').toLowerCase();

    if (mode === 'test') {
      await runTestMode(params);
    } else {
      await runRealMode(params);
    }
  } catch (err) {
    console.error('[–û—à–∏–±–∫–∞]', err.message);
    printUsage();
    process.exitCode = 1;
  }
}

function parseArgs(args) {
  const params = {};
  if (args.length === 0) return params;

  for (const raw of args) {
    const [key, ...rest] = raw.split('=');
    if (!key) throw new IllegalArgumentException(`–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä: ${raw}`);
    if (!VALID_KEYS.has(key)) throw new IllegalArgumentException(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä: ${key}`);
    const value = rest.join('='); // allow = in value
    if (value === '') throw new IllegalArgumentException(`–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ ${key}`);
    params[key] = value;
  }
  return params;
}

function printParams(params) {
  console.log('–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—É—Å–∫–∞:');
  if (Object.keys(params).length === 0) {
    console.log('  (–ø—É—Å—Ç–æ)');
    return;
  }
  for (const k of Object.keys(params)) {
    console.log(`  ${k} = ${params[k]}`);
  }
}

function validateParameters(params) {
  const mode = (params['--mode'] || 'real').toLowerCase();
  if (!['real', 'test'].includes(mode)) {
    throw new IllegalArgumentException('--mode –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å real –∏–ª–∏ test');
  }

  if (mode === 'real') {
    if (!params['--package-name']) throw new IllegalArgumentException('–í —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --package-name');
    if (!params['--version']) throw new IllegalArgumentException('–í —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --version');
    
    if (!/^[a-zA-Z0-9.\-\_]+$/.test(params['--version'])) {
      throw new IllegalArgumentException('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç --version');
    }
  } else {
    if (!params['--package-name']) throw new IllegalArgumentException('–í —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --package-name');
    if (!params['--repo-path']) throw new IllegalArgumentException('–í —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --repo-path');
  }

  if (params['--package-name']) {
    if (!/^[@a-zA-Z0-9\-\_\/\.]+$/.test(params['--package-name'])) {
      throw new IllegalArgumentException('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç --package-name');
    }
  }

  if (params['--max-depth']) {
    const n = parseInt(params['--max-depth'], 10);
    if (isNaN(n) || n <= 0 || n > 1000) {
      throw new IllegalArgumentException('--max-depth –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ü–µ–ª—ã–º –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [1..1000]');
    }
  }

  if (params['--repo-url']) {
    try {
      const u = new URL(params['--repo-url']);
      if (!['http:', 'https:'].includes(u.protocol)) {
        throw new IllegalArgumentException('--repo-url –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å http –∏–ª–∏ https');
      }
    } catch (e) {
      throw new IllegalArgumentException('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç --repo-url');
    }
  }
}


async function runTestMode(params) {
  const repoPath = params['--repo-path'];
  await validateFileExists(repoPath);
  const graph = await loadGraphFromFile(repoPath);
  const start = params['--package-name'];
  if (!graph[start]) throw new IllegalArgumentException(`–ü–∞–∫–µ—Ç '${start}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ñ–∞–π–ª–µ –≥—Ä–∞—Ñ–∞`);
  const maxDepth = params['--max-depth'] ? parseInt(params['--max-depth'], 10) : 100;
  const ascii = (params['--ascii'] || 'true').toLowerCase() !== 'false';
  const ignoreSubstring = params['--ignore-substring'] || null;

  console.log(`\n–ó–∞–ø—É—Å–∫ –≤ —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ. –ü–∞–∫–µ—Ç: ${start}. max-depth=${maxDepth}, ascii=${ascii}`);
  if (ascii) {
    printAsciiFromGraph(graph, start, { maxDepth, ignoreSubstring });
  } else {
    printFlatDepsFromGraph(graph, start, { maxDepth, ignoreSubstring });
  }
}

async function validateFileExists(filePath) {
  try {
    const stat = await fs.stat(filePath);
    if (!stat.isFile()) throw new IllegalArgumentException('--repo-path –¥–æ–ª–∂–µ–Ω —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ —Ñ–∞–π–ª');
  } catch (err) {
    if (err.code === 'ENOENT') throw new IllegalArgumentException(`–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: ${filePath}`);
    throw new IllegalArgumentException(`–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª—É: ${err.message}`);
  }
}

async function loadGraphFromFile(filePath) {
  try {
    const txt = await fs.readFile(filePath, 'utf8');
    const graph = {};
    const lines = txt.split(/\r?\n/);
    for (const raw of lines) {
      const line = raw.trim();
      if (!line) continue;
      const parts = line.split(':');
      if (parts.length < 1) continue;
      const pkg = parts[0].trim();
      const depsPart = parts.slice(1).join(':').trim();
      const deps = depsPart ? depsPart.split(/\s+/).filter(Boolean) : [];
      graph[pkg] = deps;
    }
    console.log(`–ó–∞–≥—Ä—É–∂–µ–Ω –≥—Ä–∞—Ñ (${Object.keys(graph).length} –ø–∞–∫–µ—Ç–æ–≤)`);
    return graph;
  } catch (err) {
    throw new Error(`–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: ${err.message}`);
  }
}

async function runRealMode(params) {
  const packageName = params['--package-name'];
  const version = params['--version'];
  const baseUrl = (params['--repo-url'] || 'https://registry.npmjs.org/').replace(/\/+$/, '') + '/';
  const maxDepth = params['--max-depth'] ? parseInt(params['--max-depth'], 10) : 100;
  const ascii = (params['--ascii'] || 'true').toLowerCase() !== 'false';
  const ignoreSubstring = params['--ignore-substring'] || null;

  console.log(`\n–†–µ–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º. –ü–∞–∫–µ—Ç: ${packageName}@${version}. registry=${baseUrl} max-depth=${maxDepth} ascii=${ascii}`);

  const metaCache = new Map();

  async function getDeps(pkgName, ver) {
    const cacheKey = `${pkgName}@${ver || 'LATEST'}`;
    if (metaCache.has(cacheKey)) return metaCache.get(cacheKey);

    const pkgUrl = baseUrl + encodeURIComponent(pkgName);
    let data;
    try {
      data = await fetchJson(pkgUrl);
    } catch (err) {
      metaCache.set(cacheKey, null);
      return null;
    }

    let parsed;
    try {
      parsed = JSON.parse(data);
    } catch (e) {
      metaCache.set(cacheKey, null);
      return null;
    }

    let chosenVersion = ver;
    if (!chosenVersion) {
      chosenVersion = parsed['dist-tags'] && parsed['dist-tags'].latest;
      if (!chosenVersion) {
        const versions = Object.keys(parsed.versions || {});
        chosenVersion = versions.sort().pop();
      }
    }

    const versionObj = (parsed.versions && parsed.versions[chosenVersion]) || null;
    const depsObj = versionObj && versionObj.dependencies ? versionObj.dependencies : {};
    const deps = Object.keys(depsObj || {});
    metaCache.set(cacheKey, { deps, resolvedVersion: chosenVersion });
    return metaCache.get(cacheKey);
  }

  const rootMeta = await getDeps(packageName, version);
  if (!rootMeta) {
    throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –¥–ª—è ${packageName} (${version})`);
  }
  const rootDeps = rootMeta.deps;
  console.log(`–ü—Ä—è–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ ${packageName}@${rootMeta.resolvedVersion}: ${rootDeps.length ? rootDeps.join(', ') : '(–Ω–µ—Ç)'}`);

  const fetchChildren = async (pkg) => {

    const m = await getDeps(pkg, null);
    return m && m.deps ? m.deps : [];
  };

  if (ascii) {
    await printAsciiFromFetcher(packageName, { fetchChildren, maxDepth, ignoreSubstring });
  } else {
    await printFlatFromFetcher(packageName, { fetchChildren, maxDepth, ignoreSubstring });
  }
}

function fetchJson(urlStr, timeout = 8000) {
  return new Promise((resolve, reject) => {
    const protocol = urlStr.startsWith('https:') ? https : http;
    const req = protocol.get(urlStr, (res) => {
      const { statusCode } = res;
      if (statusCode !== 200) {
        let body = '';
        res.on('data', (c) => body += c);
        res.on('end', () => reject(new Error(`HTTP ${statusCode} –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ ${urlStr}`)));
        return;
      }
      let data = '';
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => resolve(data));
    });

    req.on('error', (err) => reject(err));
    req.setTimeout(timeout, () => {
      req.destroy();
      reject(new Error('–¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è'));
    });
  });
}

function printAsciiFromGraph(graph, start, options = {}) {
  const maxDepth = options.maxDepth || 100;
  const ignoreSubstring = options.ignoreSubstring || null;

  const stack = [];
  const pathSet = new Set();
  const globalVisited = new Set();
  const rootDeps = graph[start] || [];
  stack.push({ node: start, deps: rootDeps, index: 0, depth: 0, prefixParts: [] });

  while (stack.length > 0) {
    const frame = stack[stack.length - 1];

    if (frame.index === 0) {
        printLine(frame.node, frame.depth, frame.prefixParts, { isRoot: frame.depth === 0 });
        pathSet.add(frame.node);
    }

    if (frame.depth >= maxDepth) {
      if (frame.index === 0 && (frame.deps || []).length > 0) {
        console.log(getPrefix(frame.depth, frame.prefixParts) + (frame.depth === 0 ? '' : '‚îî‚îÄ‚îÄ ') + '... (max depth reached)');
      }
      pathSet.delete(frame.node);
      globalVisited.add(frame.node);
      stack.pop();
      continue;
    }

    if (!frame.deps || frame.index >= frame.deps.length) {
      pathSet.delete(frame.node);
      globalVisited.add(frame.node);
      stack.pop();
      continue;
    }

    const child = frame.deps[frame.index++];
    if (ignoreSubstring && child.includes(ignoreSubstring)) {
      console.log(getPrefix(frame.depth + 1, frame.prefixParts.concat([frame.index < frame.deps.length])) + '‚îî‚îÄ‚îÄ ' + `${child} [–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–æ]`);
      continue;
    }

    const childPrefixParts = frame.prefixParts.concat([frame.index < frame.deps.length]);
    if (!graph[child]) {
      console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child} (–Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –≥—Ä–∞—Ñ–µ)`);
      continue;
    }

    if (pathSet.has(child)) {
      console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child} (—Ü–∏–∫–ª–∏—á–µ—Å–∫–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å)`);
      continue;
    }

    if (globalVisited.has(child)) {
      console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child} (—É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω)`);
      continue;
    }

    const childDeps = graph[child] || [];
    console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child}`);
    stack.push({ node: child, deps: childDeps, index: 0, depth: frame.depth + 1, prefixParts: childPrefixParts });
  }
}


async function printAsciiFromFetcher(start, opts = {}) {
  const maxDepth = opts.maxDepth || 100;
  const ignoreSubstring = opts.ignoreSubstring || null;
  const fetchChildren = opts.fetchChildren;
  if (typeof fetchChildren !== 'function') throw new Error('fetchChildren function required');

  const stack = [];
  const pathSet = new Set();
  const globalVisited = new Set();

  stack.push({ node: start, deps: null, index: 0, depth: 0, prefixParts: [], loading: true });

  while (stack.length > 0) {
    const frame = stack[stack.length - 1];

    if (frame.deps === null) {
      try {
        const deps = await fetchChildren(frame.node);
        frame.deps = Array.isArray(deps) ? deps : [];
      } catch (e) {
        frame.deps = [];
      }
    }

    if (frame.index === 0) {
      printLine(frame.node, frame.depth, frame.prefixParts, { isRoot: frame.depth === 0 });
      pathSet.add(frame.node);
    }

    if (frame.depth >= maxDepth) {
      if (frame.index === 0 && (frame.deps || []).length > 0) {
        console.log(getPrefix(frame.depth, frame.prefixParts) + (frame.depth === 0 ? '' : '‚îî‚îÄ‚îÄ ') + '... (max depth reached)');
      }
      pathSet.delete(frame.node);
      globalVisited.add(frame.node);
      stack.pop();
      continue;
    }

    if (!frame.deps || frame.index >= frame.deps.length) {
      pathSet.delete(frame.node);
      globalVisited.add(frame.node);
      stack.pop();
      continue;
    }

    const child = frame.deps[frame.index++];

    if (ignoreSubstring && child.includes(ignoreSubstring)) {
      console.log(getPrefix(frame.depth + 1, frame.prefixParts.concat([frame.index < frame.deps.length])) + '‚îî‚îÄ‚îÄ ' + `${child} [–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–æ]`);
      continue;
    }

    const childPrefixParts = frame.prefixParts.concat([frame.index < frame.deps.length]);

    let childDeps;
    try {
      const info = await opts.fetchChildren(child); // returns array
      childDeps = Array.isArray(info) ? info : [];
    } catch (e) {
      childDeps = null;
    }

    if (!childDeps || childDeps.length === 0) {
      console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child}${childDeps === null ? ' (–Ω–µ –Ω–∞–π–¥–µ–Ω/–æ—à–∏–±–∫–∞)' : ''}`);
      continue;
    }

    if (pathSet.has(child)) {
      console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child} (—Ü–∏–∫–ª–∏—á–µ—Å–∫–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å)`);
      continue;
    }

    if (globalVisited.has(child)) {
      console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child} (—É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω)`);
      continue;
    }

    console.log(getPrefix(frame.depth + 1, childPrefixParts) + '‚îî‚îÄ‚îÄ ' + `${child}`);
    stack.push({ node: child, deps: childDeps, index: 0, depth: frame.depth + 1, prefixParts: childPrefixParts });
  }
}

function printFlatDepsFromGraph(graph, start, options = {}) {
  const maxDepth = options.maxDepth || 100;
  const ignoreSubstring = options.ignoreSubstring || null;

  const stack = [{ node: start, deps: graph[start] || [], index: 0, depth: 0 }];
  const visited = new Set();
  const results = [];

  while (stack.length) {
    const frame = stack[stack.length - 1];
    if (frame.index === 0) {
      visited.add(frame.node);
    }
    if (frame.index >= frame.deps.length) {
      stack.pop();
      continue;
    }
    const child = frame.deps[frame.index++];
    if (ignoreSubstring && child.includes(ignoreSubstring)) continue;
    results.push({ parent: frame.node, child, depth: frame.depth + 1 });
    if (!visited.has(child) && frame.depth + 1 < maxDepth && graph[child]) {
      stack.push({ node: child, deps: graph[child], index: 0, depth: frame.depth + 1 });
    }
  }

  console.log('–°–ø–∏—Å–æ–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (parent -> child):');
  for (const r of results) {
    console.log(`${'  '.repeat(r.depth - 1)}${r.parent} -> ${r.child}`);
  }
}

async function printFlatFromFetcher(start, opts = {}) {
  const maxDepth = opts.maxDepth || 100;
  const ignoreSubstring = opts.ignoreSubstring || null;
  const fetchChildren = opts.fetchChildren;
  if (typeof fetchChildren !== 'function') throw new Error('fetchChildren function required');

  const stack = [{ node: start, deps: null, index: 0, depth: 0 }];
  const visited = new Set();
  const results = [];

  while (stack.length) {
    const frame = stack[stack.length - 1];
    if (frame.deps === null) {
      frame.deps = await fetchChildren(frame.node) || [];
    }
    if (frame.index === 0) visited.add(frame.node);
    if (frame.index >= frame.deps.length) {
      stack.pop();
      continue;
    }
    const child = frame.deps[frame.index++];
    if (ignoreSubstring && child.includes(ignoreSubstring)) continue;
    results.push({ parent: frame.node, child, depth: frame.depth + 1 });
    if (!visited.has(child) && frame.depth + 1 < maxDepth) {
      stack.push({ node: child, deps: null, index: 0, depth: frame.depth + 1 });
    }
  }

  console.log('–°–ø–∏—Å–æ–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (parent -> child):');
  for (const r of results) {
    console.log(`${'  '.repeat(r.depth - 1)}${r.parent} -> ${r.child}`);
  }
}

function getPrefix(depth, prefixParts) {
  let s = '';
  for (let i = 0; i < prefixParts.length - 1; i++) {
    s += prefixParts[i] ? '‚îÇ   ' : '    ';
  }
  return s;
}

function printLine(node, depth, prefixParts, { isRoot = false } = {}) {
  if (isRoot) {
    console.log(node);
  } else {

    console.log(getPrefix(depth, prefixParts) + (depth === 0 ? '' : '‚îî‚îÄ‚îÄ ') + node);
  }
}


function printUsage() {
  console.log(`
–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
–†–µ–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º:
  node dep-visualizer.js --mode=real --package-name=<–∏–º—è> --version=<–≤–µ—Ä—Å–∏—è> [--repo-url=<registry-url>] [--ascii=true|false] [--max-depth=10]

–¢–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º:
  node dep-visualizer.js --mode=test --package-name=<A> --repo-path=<–ø—É—Ç—å-–∫-—Ñ–∞–π–ª—É> [--ascii=true|false] [--max-depth=10]

–§–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –≥—Ä–∞—Ñ–∞:
  A: B C D
  B: E F
  C: G
  D:
  E: A
`);
}

module.exports = {
  main,
  parseArgs,
  validateParameters,
  loadGraphFromFile,
  printAsciiFromGraph,
  printAsciiFromFetcher,
  printFlatDepsFromGraph,
  printFlatFromFetcher,
  fetchJson
};


if (require.main === module) {
  main().catch(err => {
    console.error('[–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞]', err);
    process.exitCode = 1;
  });
}

```

## –≠—Ç–∞–ø 4.
### –¶–µ–ª—å
–í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ –≥—Ä–∞—Ñ–æ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π.
### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è
1. (—Ç–æ–ª—å–∫–æ –¥–ª—è —ç—Ç–æ–≥–æ —ç—Ç–∞–ø–∞) –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–µ–∂–∏–º –≤—ã–≤–æ–¥–∞ –Ω–∞ —ç–∫—Ä–∞–Ω –ø–æ—Ä—è–¥–∫–∞
–∑–∞–≥—Ä—É–∑–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø–∞–∫–µ—Ç–∞. –°—Ä–∞–≤–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å
—Ä–µ–∞–ª—å–Ω—ã–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º –ø–∞–∫–µ—Ç–æ–≤. –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏—è –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö,
–æ–±—ä—è—Å–Ω–∏—Ç—å –∏—Ö –Ω–∞–ª–∏—á–∏–µ.
2. –ü—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å —ç—Ç–æ–≥–æ —ç—Ç–∞–ø–∞ –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö
—Ä–∞–±–æ—Ç—ã —Å —Ç–µ—Å—Ç–æ–≤—ã–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–º.
3. –†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–∞–ø–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ
–æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ã–º –∫–æ–º–º–∏—Ç–æ–º.

### –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞–ø—É—Å–∫–∞
<img width="1345" height="603" alt="image" src="https://github.com/user-attachments/assets/ffe7932b-61e0-4cc3-945b-16a53ec0d5da" />
<img width="1287" height="1075" alt="image" src="https://github.com/user-attachments/assets/9a2c2c71-90f5-4cc5-ba98-a80383a8b40d" />
<img width="1405" height="382" alt="image" src="https://github.com/user-attachments/assets/dc9ffba1-a8cf-42a3-aca0-1337ee0679a4" />
<img width="1276" height="593" alt="image" src="https://github.com/user-attachments/assets/3ab16f75-8dd0-4212-8820-5ab987811038" />

### –ö–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã
```js

const https = require('https');
const http = require('http');
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const os = require('os');
const { execSync } = require('child_process');

const VALID_KEYS = new Set([
    '--package-name', '--repo-url', '--repo-path',
    '--mode', '--version', '--ascii', '--max-depth',
    '--show-order', '--compare-npm'
]);

class IllegalArgumentException extends Error {
    constructor(message) {
        super(message);
        this.name = 'IllegalArgumentException';
    }
}

class FourthStage {
    constructor() {
        this.params = {};
        this.fetchCache = new Map(); 
    }

    async main(args) {
        try {
            this.parseArgs(args);
            this.validateParameters();

            const mode = (this.params['--mode'] || 'real').toLowerCase();

            if (mode === 'test') {
                await this.runTestMode();
            } else {
                await this.runRealMode();
            }

        } catch (error) {
            if (error instanceof IllegalArgumentException) {
                console.error('[–û—à–∏–±–∫–∞]', error.message);
                this.printUsage();
            } else {
                console.error('[–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞]', error && error.stack ? error.stack : error);
            }
            process.exitCode = 1;
        }
    }

    async runTestMode() {
        const repoPath = this.params['--repo-path'];
        if (!repoPath) throw new IllegalArgumentException('–í —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --repo-path');

        await this.validateFileExists(repoPath);

        const graph = await this.loadGraphFromFile(repoPath);
        const startPackage = this.params['--package-name'];
        const ignoreSubstring = this.params['--ignore-substring'] || null;
        const maxDepth = this.params['--max-depth'] ? parseInt(this.params['--max-depth'], 10) : 100;
        const ascii = (this.params['--ascii'] || 'true').toLowerCase() !== 'false';

        if (!graph[startPackage]) {
            throw new IllegalArgumentException(`–£–∫–∞–∑–∞–Ω–Ω—ã–π –ø–∞–∫–µ—Ç '${startPackage}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ç–µ—Å—Ç–æ–≤–æ–º –≥—Ä–∞—Ñ–µ`);
        }

        if (this.params['--show-order']) {
            console.log(`\nüîç –ê–Ω–∞–ª–∏–∑ –ø–æ—Ä—è–¥–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–ª—è –ø–∞–∫–µ—Ç–∞ '${startPackage}' (—Ç–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º):`);
            const { order, cycles } = this.getLoadOrder(graph, startPackage, { ignoreSubstring, maxDepth });
            if (cycles.length) {
                console.log('   ‚ùå –¶–∏–∫–ª—ã –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã:');
                cycles.forEach(c => console.log(`     ‚Ä¢ ${c.join(' ‚Üí ')}`));
            } else {
                console.log('   ‚úÖ –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –ø–æ—Ä—è–¥–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏:');
                order.forEach((p, i) => console.log(`     ${i + 1}. ${p}`));
            }
        } else {
            console.log(`\n–ì—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (—Ç–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º) –¥–ª—è –ø–∞–∫–µ—Ç–∞ '${startPackage}':`);
            if (ascii) {
                this.printAsciiFromGraph(graph, startPackage, { maxDepth, ignoreSubstring });
            } else {
                this.dfsIterative(graph, startPackage, ignoreSubstring, maxDepth);
            }
        }
    }

    async runRealMode() {
        const packageName = this.params['--package-name'];
        const version = this.params['--version'];

        if (!packageName) throw new IllegalArgumentException('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --package-name –≤ —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ');
        if (!version && !this.params['--compare-npm']) throw new IllegalArgumentException('–í —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --version');

        if (this.params['--compare-npm']) {
            await this.compareWithNpm(packageName, version);
            return;
        }

        let baseUrl = this.params['--repo-url'] || 'https://registry.npmjs.org/';
        if (!baseUrl.endsWith('/')) baseUrl += '/';

        const maxDepth = this.params['--max-depth'] ? parseInt(this.params['--max-depth'], 10) : 100;
        const ascii = (this.params['--ascii'] || 'true').toLowerCase() !== 'false';
        const ignoreSubstring = this.params['--ignore-substring'] || null;

        console.log(`\n–†–µ–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º. –ü–∞–∫–µ—Ç: ${packageName}@${version}. registry=${baseUrl} max-depth=${maxDepth}`);

        const graph = await this.buildGraphFromRegistry(packageName, version, baseUrl, maxDepth);

        if (!graph || Object.keys(graph).length === 0) {
            console.log(`–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è ${packageName}@${version} –∏–ª–∏ –∏—Ö –Ω–µ—Ç.`);
            return;
        }

        if (this.params['--show-order']) {
            console.log(`\nüîç –ê–Ω–∞–ª–∏–∑ –ø–æ—Ä—è–¥–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–ª—è –ø–∞–∫–µ—Ç–∞ '${packageName}@${version}' (—Ä–µ–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º):`);
            const { order, cycles } = this.getLoadOrder(graph, packageName, { ignoreSubstring, maxDepth });
            if (cycles.length) {
                console.log('   ‚ùå –¶–∏–∫–ª—ã –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã:');
                cycles.forEach(c => console.log(`     ‚Ä¢ ${c.join(' ‚Üí ')}`));
            } else {
                console.log('   ‚úÖ –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –ø–æ—Ä—è–¥–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏:');
                order.forEach((p, i) => console.log(`     ${i + 1}. ${p}`));
            }
        } else {
            console.log('–ì—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (–ø–æ–ª–Ω—ã–π):');
            if (ascii) {
                this.printAsciiFromGraph(graph, packageName, { maxDepth, ignoreSubstring });
            } else {
                this.dfsIterative(graph, packageName, ignoreSubstring, maxDepth);
            }
        }
    }

    async buildGraphFromRegistry(rootName, rootVersion, baseUrl, maxDepth = 100) {
        const graph = {};
        const toProcess = [{ name: rootName, version: rootVersion, depth: 0 }];
        const seen = new Set(); 

        while (toProcess.length > 0) {
            const { name, version, depth } = toProcess.shift();
            const key = `${name}@${version || 'latest'}`;
            if (seen.has(key)) continue;
            seen.add(key);

            if (depth > maxDepth) continue;

            const meta = await this.getPackageMeta(name, version, baseUrl);
            if (!meta) {
                graph[name] = graph[name] || [];
                continue;
            }

            const deps = meta.deps || [];
            graph[name] = deps;

            for (const dep of deps) {
                if (!dep) continue;
                toProcess.push({ name: dep, version: null, depth: depth + 1 });
            }
        }

        return graph;
    }

    async getPackageMeta(pkgName, ver, baseUrl) {
        const cacheKey = `${pkgName}@${ver || 'latest'}@${baseUrl}`;
        if (this.fetchCache.has(cacheKey)) return this.fetchCache.get(cacheKey);

        const pkgUrl = baseUrl + encodeURIComponent(pkgName);
        let data;
        try {
            data = await this.fetchJson(pkgUrl);
        } catch (e) {
            this.fetchCache.set(cacheKey, null);
            return null;
        }

        let parsed;
        try {
            parsed = JSON.parse(data);
        } catch (e) {
            this.fetchCache.set(cacheKey, null);
            return null;
        }

        // choose version
        let chosenVersion = ver;
        if (!chosenVersion) {
            chosenVersion = (parsed['dist-tags'] && parsed['dist-tags'].latest) || null;
            if (!chosenVersion) {
                const vs = Object.keys(parsed.versions || {});
                chosenVersion = vs.length ? vs.sort().pop() : null;
            }
        }

        const versionObj = (parsed.versions && parsed.versions[chosenVersion]) || null;
        const depsObj = versionObj && versionObj.dependencies ? versionObj.dependencies : {};
        const deps = Object.keys(depsObj || {});
        const meta = { deps, resolvedVersion: chosenVersion };
        this.fetchCache.set(cacheKey, meta);
        return meta;
    }

    getLoadOrder(graph, start, opts = {}) {
        const ignoreSubstring = opts.ignoreSubstring || null;
        const maxDepth = opts.maxDepth || Infinity;

        const reachable = new Set();
        const q = [{ node: start, depth: 0 }];
        while (q.length) {
            const { node, depth } = q.shift();
            if (reachable.has(node)) continue;
            if (depth > maxDepth) continue;
            reachable.add(node);
            const deps = graph[node] || [];
            for (const d of deps) {
                if (ignoreSubstring && d.includes(ignoreSubstring)) continue;
                q.push({ node: d, depth: depth + 1 });
            }
        }

        const indeg = {};
        for (const n of reachable) indeg[n] = 0;
        for (const n of reachable) {
            for (const dep of graph[n] || []) {
                if (!reachable.has(dep)) continue;
                if (ignoreSubstring && dep.includes(ignoreSubstring)) continue;
                indeg[dep] = (indeg[dep] || 0) + 1;
            }
        }

        const zero = [];
        for (const [n, d] of Object.entries(indeg)) {
            if (d === 0) zero.push(n);
        }

        const order = [];
        while (zero.length) {
            const n = zero.shift();
            order.push(n);
            for (const dep of graph[n] || []) {
                if (!reachable.has(dep)) continue;
                if (ignoreSubstring && dep.includes(ignoreSubstring)) continue;
                indeg[dep]--;
                if (indeg[dep] === 0) zero.push(dep);
            }
        }

        const cycles = [];
        const remaining = [...reachable].filter(n => !order.includes(n));
        if (remaining.length) {
            const visited = new Set();
            const stack = [];
            const onStack = new Set();

            const dfs = (v) => {
                visited.add(v);
                stack.push(v);
                onStack.add(v);
                for (const w of graph[v] || []) {
                    if (!reachable.has(w)) continue;
                    if (!visited.has(w)) {
                        dfs(w);
                    } else if (onStack.has(w)) {
                        // extract cycle
                        const idx = stack.indexOf(w);
                        if (idx !== -1) {
                            const cyc = stack.slice(idx);
                            cycles.push(cyc.concat(w)); // close cycle
                        }
                    }
                }
                stack.pop();
                onStack.delete(v);
            };

            for (const v of remaining) {
                if (!visited.has(v)) dfs(v);
            }
        }

        return { order, cycles };
    }


    async compareWithNpm(packageName, version) {
        console.log(`\nüîç –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å npm –¥–ª—è ${packageName}@${version}...`);

        const tmpBase = os.tmpdir();
        const tmpPrefix = path.join(tmpBase, 'npm-compare-');
        let tempDir;
        try {
            tempDir = await fs.mkdtemp(tmpPrefix);
        } catch (e) {
            console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é:', e.message);
            return;
        }

        try {
            const pkgJson = {
                name: 'compare-test',
                version: '1.0.0',
                description: 'temp for dependency order comparison',
                private: true,
                dependencies: {
                    [packageName]: version
                }
            };
            await fs.writeFile(path.join(tempDir, 'package.json'), JSON.stringify(pkgJson, null, 2), 'utf8');

            console.log('üì¶ –ó–∞–ø—É—Å–∫–∞—é npm install (–º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è)...');
            try {
                execSync('npm install --no-audit --no-fund', { cwd: tempDir, stdio: 'inherit', timeout: 10 * 60 * 1000 });
            } catch (npmErr) {
                console.warn('npm install –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –∫–æ–¥–æ–º –æ—à–∏–±–∫–∏ –∏–ª–∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ–º (–ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∞–Ω–∞–ª–∏–∑) ‚Äî —Å–º. –≤—ã–≤–æ–¥ –≤—ã—à–µ');
            }

            let lsOutput = null;
            try {
                lsOutput = execSync('npm ls --all --json', { cwd: tempDir, encoding: 'utf8', timeout: 60 * 1000 });
            } catch (err) {
                if (err.stdout) lsOutput = err.stdout.toString();
                else if (err.stderr) lsOutput = err.stderr.toString();
                else lsOutput = null;
            }

            if (!lsOutput) {
                console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ä–µ–≤–æ npm (npm ls –Ω–µ –≤–µ—Ä–Ω—É–ª JSON)');
                return;
            }

            let npmTree;
            try {
                npmTree = JSON.parse(lsOutput);
            } catch (e) {
                console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON –∏–∑ npm ls:', e.message);
                return;
            }

            const baseUrl = this.params['--repo-url'] || 'https://registry.npmjs.org/';
            const ourGraph = await this.buildGraphFromRegistry(packageName, version, baseUrl, this.params['--max-depth'] ? parseInt(this.params['--max-depth'], 10) : 100);

            const npmOrderList = this.extractOrderFromNpmTree(npmTree, packageName);

            const { order: ourOrder, cycles } = this.getLoadOrder(ourGraph, packageName, { ignoreSubstring: this.params['--ignore-substring'] || null });

            console.log('\nüîÅ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ—Ä—è–¥–∫–∞:');
            console.log(`   ‚Ä¢ –ü–æ—Ä—è–¥–æ–∫ npm (–∫–æ–ª-–≤–æ): ${npmOrderList.length}`);
            console.log(`   ‚Ä¢ –ù–∞—à –ø–æ—Ä—è–¥–æ–∫ (–∫–æ–ª-–≤–æ): ${ourOrder.length}`);
            console.log('\n   npm (–ø–µ—Ä–≤—ã–µ 20):');
            npmOrderList.slice(0, 20).forEach((p, i) => console.log(`     ${i + 1}. ${p}`));
            console.log('\n   –ù–∞—à (–ø–µ—Ä–≤—ã–µ 20):');
            ourOrder.slice(0, 20).forEach((p, i) => console.log(`     ${i + 1}. ${p}`));

            const npmSet = new Set(npmOrderList);
            const ourSet = new Set(ourOrder);
            const onlyInNpm = [...npmSet].filter(x => !ourSet.has(x));
            const onlyInOurs = [...ourSet].filter(x => !npmSet.has(x));

            console.log('\n   –û—Ç–ª–∏—á–∏—è (–ø–∞–∫–µ—Ç—ã –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç —Ç–æ–ª—å–∫–æ –≤ –æ–¥–Ω–æ–π –∏–∑ –¥–≤—É—Ö –≤–µ—Ä—Å–∏–π):');
            console.log(`     ‚Ä¢ –í npm, –Ω–æ –Ω–µ—Ç —É –Ω–∞—Å: ${onlyInNpm.length ? onlyInNpm.slice(0, 20).join(', ') : '(–Ω–µ—Ç)'}`);
            console.log(`     ‚Ä¢ –£ –Ω–∞—Å, –Ω–æ –Ω–µ—Ç –≤ npm: ${onlyInOurs.length ? onlyInOurs.slice(0, 20).join(', ') : '(–Ω–µ—Ç)'}`);

            if (cycles.length) {
                console.log('\n   ‚ùó –£ –Ω–∞—Å –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã —Ü–∏–∫–ª—ã –≤ –≥—Ä–∞—Ñ–µ (–≤–ª–∏—è–µ—Ç –Ω–∞ –ø–æ—Ä—è–¥–æ–∫):');
                cycles.forEach(c => console.log(`     ‚Ä¢ ${c.join(' ‚Üí ')}`));
            }

            console.log('\n   –ü–æ—è—Å–Ω–µ–Ω–∏—è –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–π:');
            console.log('     ‚Ä¢ npm –∏—Å–ø–æ–ª—å–∑—É–µ—Ç hoisting/flattening/lockfile/peerDependencies/optionalDeps, —á—Ç–æ –º–µ–Ω—è–µ—Ç –∏—Ç–æ–≥–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É.');
            console.log('     ‚Ä¢ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –ø–æ—Ä—è–¥–æ–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π, npm –º–æ–∂–µ—Ç —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –∏ —Ö–æ—Å—Ç–∏—Ç—å –ø–∞–∫–µ—Ç—ã.');
            console.log('     ‚Ä¢ package-lock.json –∏ npm cache –≤–ª–∏—è—é—Ç –Ω–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–π –∏ –ø–æ—Ä—è–¥–æ–∫.');
            console.log('     ‚Ä¢ peerDependencies / optionalDependencies –º–æ–≥—É—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è –ø–æ-–¥—Ä—É–≥–æ–º—É.');

        } finally {
            try {
                await fs.rm(tempDir, { recursive: true, force: true });
            } catch (e) {
            }
        }
    }

    extractOrderFromNpmTree(npmTree, rootPackageName) {
        const result = [];
        const visited = new Set();

        function traverse(node, depth = 0) {
            if (!node || !node.dependencies) return;
            for (const [name, info] of Object.entries(node.dependencies)) {
                if (visited.has(name)) continue;
                visited.add(name);
                result.push(name);
                traverse(info, depth + 1);
            }
        }

        traverse(npmTree);
        return result;
    }

    fetchJson(urlStr, timeout = 15000) {
        return new Promise((resolve, reject) => {
            const protocol = urlStr.startsWith('https:') ? https : http;
            const req = protocol.get(urlStr, (res) => {
                if (res.statusCode !== 200) {
                    // collect body for message
                    let body = '';
                    res.on('data', (c) => body += c);
                    res.on('end', () => reject(new Error(`HTTP ${res.statusCode} –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ ${urlStr}`)));
                    return;
                }
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => resolve(data));
            });

            req.on('error', (err) => reject(err));
            req.setTimeout(timeout, () => {
                req.destroy();
                reject(new Error('–¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è'));
            });
        });
    }

    async loadGraphFromFile(filePath) {
        const graph = {};

        try {
            const data = await fs.readFile(filePath, 'utf8');
            const lines = data.split(/\r?\n/);

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;

                const parts = trimmedLine.split(':');
                if (parts.length < 1) continue;
                const pkg = parts.shift().trim();
                const depsPart = parts.join(':').trim();
                const deps = depsPart ? depsPart.split(/\s+/).filter(Boolean) : [];
                graph[pkg] = deps;
            }

            console.log(`–ó–∞–≥—Ä—É–∂–µ–Ω –≥—Ä–∞—Ñ –∏–∑ —Ñ–∞–π–ª–∞: ${Object.keys(graph).length} –ø–∞–∫–µ—Ç–æ–≤`);
            return graph;
        } catch (error) {
            throw new Error(`–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: ${error.message}`);
        }
    }

    findMatchingBrace(s, start) {
        let level = 0;
        for (let i = start; i < s.length; i++) {
            const c = s.charAt(i);
            if (c === '{') level++;
            else if (c === '}') {
                level--;
                if (level === 0) return i;
            }
        }
        return -1;
    }

    extractDependencies(jsonStr, version) {
        try {
            const parsed = JSON.parse(jsonStr);
            const ver = version;
            const versionObj = parsed && parsed.versions && parsed.versions[ver];
            if (!versionObj) return {};
            const depsObj = versionObj.dependencies || {};
            const deps = Object.keys(depsObj);
            const graph = {};
            graph[this.params['--package-name']] = deps;
            return graph;
        } catch (e) {
            return {};
        }
    }


    dfsIterative(graph, start, ignoreSubstring = null, maxDepth = 100) {
        const stack = [{ node: start, depth: 0 }];
        const visited = new Set();

        while (stack.length > 0) {
            const { node, depth } = stack.pop();

            if (visited.has(node)) {
                console.log(`‚Ü™ –¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å: ${node}`);
                continue;
            }

            visited.add(node);

            const deps = graph[node] || [];
            for (const dep of deps) {
                if (ignoreSubstring && dep.includes(ignoreSubstring)) {
                    console.log(`${'  '.repeat(depth)}- ${dep} [–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–æ]`);
                    continue;
                }
                console.log(`${'  '.repeat(depth)}- ${node} -> ${dep}`);
                if (depth + 1 < maxDepth) stack.push({ node: dep, depth: depth + 1 });
            }
        }
    }


    printAsciiFromGraph(graph, start, opts = {}) {
        const maxDepth = opts.maxDepth || 100;
        const ignoreSubstring = opts.ignoreSubstring || null;

        // We'll implement an iterative stack that keeps prefix information
        const stack = [{ node: start, depth: 0, iter: 0, deps: (graph[start] || []) }];
        const pathSet = new Set();

        // print root
        console.log(start);

        while (stack.length > 0) {
            const frame = stack[stack.length - 1];

            if (!frame.deps || frame.iter >= frame.deps.length) {
                // done with this node
                pathSet.delete(frame.node);
                stack.pop();
                continue;
            }

            const child = frame.deps[frame.iter++];
            const depth = frame.depth + 1;

            if (ignoreSubstring && child.includes(ignoreSubstring)) {
                console.log(`${'‚îÇ   '.repeat(frame.depth)}‚îî‚îÄ‚îÄ ${child} [–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–æ]`);
                continue;
            }

            const prefix = '‚îÇ   '.repeat(frame.depth) + '‚îî‚îÄ‚îÄ ';

            if (!graph[child] || graph[child].length === 0) {
                console.log(prefix + `${child} (leaf)`);
                continue;
            }

            if (pathSet.has(child)) {
                console.log(prefix + `${child} (—Ü–∏–∫–ª–∏—á–µ—Å–∫–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å)`);
                continue;
            }

            console.log(prefix + child);
            pathSet.add(child);
            const childDeps = graph[child] || [];
            if (depth <= maxDepth) {
                stack.push({ node: child, depth, iter: 0, deps: childDeps });
            } else {
                console.log('‚îÇ   '.repeat(depth - 1) + '‚îî‚îÄ‚îÄ ... (max depth reached)');
            }
        }
    }

    async validateFileExists(filePath) {
        try {
            const stats = await fs.stat(filePath);
            if (!stats.isFile()) {
                throw new IllegalArgumentException('--repo-path –¥–æ–ª–∂–µ–Ω —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ —Ñ–∞–π–ª, –∞ –Ω–µ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é');
            }
        } catch (error) {
            if (error && error.code === 'ENOENT') {
                throw new IllegalArgumentException(`–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: ${filePath}`);
            }
            throw new IllegalArgumentException(`–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª—É: ${error.message}`);
        }
    }

    validateParameters() {
        const mode = (this.params['--mode'] || 'real').toLowerCase();
        if (!['real', 'test'].includes(mode)) {
            throw new IllegalArgumentException('–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è --mode. –î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: real, test');
        }

        if (mode === 'real') {
            if (!this.params['--package-name']) {
                throw new IllegalArgumentException('–í —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --package-name');
            }
            if (!this.params['--version'] && !this.params['--compare-npm']) {
                throw new IllegalArgumentException('–í —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --version (–µ—Å–ª–∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è --compare-npm)');
            }
        } else {
            if (!this.params['--package-name']) {
                throw new IllegalArgumentException('–í —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --package-name');
            }
            if (!this.params['--repo-path']) {
                throw new IllegalArgumentException('–í —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å --repo-path');
            }
        }

        if (this.params['--max-depth']) {
            const maxDepth = parseInt(this.params['--max-depth'], 10);
            if (isNaN(maxDepth) || maxDepth <= 0 || maxDepth > 1000) {
                throw new IllegalArgumentException('--max-depth –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 1000');
            }
        }

        if (this.params['--compare-npm'] && mode === 'test') {
            console.warn('‚ö† –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: --compare-npm –ª—É—á—à–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ');
        }
    }

    parseArgs(args) {
        if (!args || args.length === 0) {
            throw new IllegalArgumentException('–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã');
        }

        for (const argument of args) {
            // allow values with '=' by splitting only on first '='
            const eqIndex = argument.indexOf('=');
            if (eqIndex === -1) {
                throw new IllegalArgumentException('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç --key=value)');
            }
            const key = argument.substring(0, eqIndex);
            const value = argument.substring(eqIndex + 1);

            if (!VALID_KEYS.has(key)) {
                throw new IllegalArgumentException(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä: ${key}`);
            }

            if (value === '') {
                throw new IllegalArgumentException(`–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ ${key}`);
            }

            this.params[key] = value;
        }
    }

    printUsage() {
        console.log(`
–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Fourth Stage:

–ë–∞–∑–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑ (—Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª):
  node fourth_stage.js --mode=test --package-name=A --repo-path=complex_graph.txt --show-order
  (–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–æ—Ä—è–¥–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏/topological order –∏ —Ü–∏–∫–ª—ã)

–†–µ–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º (npm registry):
  node fourth_stage.js --mode=real --package-name=express --version=4.18.2 --show-order --max-depth=5
  (—Å–∫–∞—á–∏–≤–∞–µ—Ç metadata –∏–∑ registry –∏ —Å—Ç—Ä–æ–∏—Ç –≥—Ä–∞—Ñ / –ø–æ—Ä—è–¥–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏)

–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å npm:
  node fourth_stage.js --package-name=react --version=18.2.0 --compare-npm

–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
  --show-order        : –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ—Ä—è–¥–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
  --compare-npm       : –°—Ä–∞–≤–Ω–∏—Ç—å —Å —Ä–µ–∞–ª—å–Ω—ã–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º –ø–∞–∫–µ—Ç–æ–≤ npm (—Å–æ–∑–¥–∞—ë—Ç—Å—è –≤—Ä–µ–º. –ø—Ä–æ–µ–∫—Ç)
  --package-name      : –ò–º—è –ø–∞–∫–µ—Ç–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
  --version           : –í–µ—Ä—Å–∏—è –ø–∞–∫–µ—Ç–∞ (—Ä–µ–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º)
  --repo-path         : –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –≥—Ä–∞—Ñ–∞ (—Ç–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º)
  --mode              : –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã (real/test)
  --ignore-substring  : –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –ø–æ–¥—Å—Ç—Ä–æ–∫—É
  --max-depth         : –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –∞–Ω–∞–ª–∏–∑–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 100)
  --repo-url          : (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) URL npm registry, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é https://registry.npmjs.org/

–ü—Ä–∏–º–µ—Ä —Ñ–∞–π–ª–∞ –≥—Ä–∞—Ñ–∞ (graph.txt):
  A: B C
  B: D E
  C: D F
  D:
  E: A
  F: G
`);
    }
}


if (require.main === module) {
    const app = new FourthStage();

    if (process.argv.length <= 2) {
        console.log('üöÄ Fourth Stage - –ê–Ω–∞–ª–∏–∑ –ø–æ—Ä—è–¥–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π');
        (async () => {
            try {
                // create an example complex_graph.txt if missing
                const example = path.join(process.cwd(), 'complex_graph.txt');
                if (!fsSync.existsSync(example)) {
                    const complexContent = `A: B C
B: D E
C: D F
D:
E: A
F: G
G: H
H: F
I: J K
J: L
K: M
L:
M:`;
                    await fs.writeFile(example, complexContent, 'utf8');
                    console.log('‚úÖ –°–æ–∑–¥–∞–Ω —Å–ª–æ–∂–Ω—ã–π –ø—Ä–∏–º–µ—Ä —Ñ–∞–π–ª–∞ –≥—Ä–∞—Ñ–∞: complex_graph.txt');
                }
            } catch (e) { /* ignore */ }
            app.printUsage();
        })();
    } else {
        app.main(process.argv.slice(2));
    }
}

module.exports = FourthStage;

```
